import "./chunk-VKLSQVZX.js";

// node_modules/maska/dist/maska.js
var P = Object.defineProperty;
var C = (a, s, t) => s in a ? P(a, s, { enumerable: true, configurable: true, writable: true, value: t }) : a[s] = t;
var p = (a, s, t) => (C(a, typeof s != "symbol" ? s + "" : s, t), t);
var T = {
  "#": { pattern: /[0-9]/ },
  "@": { pattern: /[a-zA-Z]/ },
  "*": { pattern: /[a-zA-Z0-9]/ }
};
var L = class {
  constructor(s = {}) {
    p(this, "mask", "");
    p(this, "tokens", T);
    p(this, "eager", false);
    p(this, "reversed", false);
    p(this, "memo", /* @__PURE__ */ new Map());
    var t;
    if (s.tokens != null) {
      s.tokens = s.tokensReplace ? { ...s.tokens } : { ...T, ...s.tokens };
      for (const e of Object.values(s.tokens))
        typeof e.pattern == "string" && (e.pattern = new RegExp(e.pattern));
    }
    s.mask == null ? s.mask = "" : typeof s.mask == "object" && (s.mask.length > 1 ? s.mask.sort((e, n) => e.length - n.length) : s.mask = (t = s.mask[0]) != null ? t : ""), Object.assign(this, s);
  }
  masked(s) {
    return this.process(s, this.findMask(s));
  }
  unmasked(s) {
    return this.process(s, this.findMask(s), false);
  }
  completed(s) {
    const t = this.process(s, this.findMask(s)).length;
    return typeof this.mask == "string" ? t >= this.mask.length : typeof this.mask == "function" ? t >= this.findMask(s).length : this.mask.filter((e) => t >= e.length).length === this.mask.length;
  }
  findMask(s) {
    var e, n;
    if (typeof this.mask == "string")
      return this.mask;
    if (typeof this.mask == "function")
      return this.mask(s);
    const t = this.process(s, (e = this.mask.slice(-1).pop()) != null ? e : "", false);
    return (n = this.mask.find(
      (i) => this.process(s, i, false).length >= t.length
    )) != null ? n : "";
  }
  escapeMask(s) {
    const t = [], e = [];
    return s.split("").forEach((n, i) => {
      n === "!" && s[i - 1] !== "!" ? e.push(i - e.length) : t.push(n);
    }), { mask: t.join(""), escaped: e };
  }
  process(s, t, e = true) {
    var A;
    const n = `value=${s},mask=${t},masked=${e ? 1 : 0}`;
    if (this.memo.has(n))
      return this.memo.get(n);
    const { mask: i, escaped: h } = this.escapeMask(t), l = [], r = this.reversed ? -1 : 1, f = this.reversed ? "unshift" : "push", u = this.reversed ? 0 : i.length - 1, R = this.reversed ? () => o > -1 && c > -1 : () => o < i.length && c < s.length, W = (m) => !this.reversed && m <= u || this.reversed && m >= u;
    let M, d = -1, o = this.reversed ? i.length - 1 : 0, c = this.reversed ? s.length - 1 : 0;
    for (; R(); ) {
      const m = i.charAt(o), k = this.tokens[m], g = (k == null ? void 0 : k.transform) != null ? k.transform(s.charAt(c)) : s.charAt(c);
      if (!h.includes(o) && k != null) {
        if (g.match(k.pattern) != null)
          l[f](g), k.repeated ? (d === -1 ? d = o : o === u && o !== d && (o = d - r), u === d && (o -= r)) : k.multiple && (o -= r), o += r;
        else if (k.multiple) {
          const b = ((A = l[c - r]) == null ? void 0 : A.match(k.pattern)) != null, v = i.charAt(o + r);
          b && v !== "" && this.tokens[v] == null ? (o += r, c -= r) : l[f]("");
        } else
          g === M ? M = void 0 : k.optional && (o += r, c -= r);
        c += r;
      } else
        e && !this.eager && l[f](m), g === m && !this.eager ? c += r : M = m, this.eager || (o += r);
      if (this.eager)
        for (; W(o) && (this.tokens[i.charAt(o)] == null || h.includes(o)); )
          e ? l[f](i.charAt(o)) : i.charAt(o) === s.charAt(c) && (c += r), o += r;
    }
    return this.memo.set(n, l.join("")), this.memo.get(n);
  }
};
var w = (a) => JSON.parse(a.replaceAll("'", '"'));
var y = (a) => a !== "" ? Boolean(JSON.parse(a)) : true;
var O = (a) => a.startsWith("[") && a.endsWith("]") ? w(a) : a;
var S = (a) => {
  if (a.startsWith("{") && a.endsWith("}"))
    return w(a);
  const s = {};
  return a.split("|").forEach((t) => {
    const e = t.split(":");
    s[e[0]] = {
      pattern: new RegExp(e[1]),
      optional: e[2] === "optional",
      multiple: e[2] === "multiple",
      repeated: e[2] === "repeated"
    };
  }), s;
};
var j = class {
  constructor(s, t = {}) {
    p(this, "items", /* @__PURE__ */ new Map());
    p(this, "beforeinputEvent", (s2) => {
      const t2 = s2.target, e2 = this.items.get(t2);
      e2.eager && "inputType" in s2 && s2.inputType.startsWith("delete") && e2.unmasked(t2.value).length <= 1 && this.setMaskedValue(t2, "");
    });
    p(this, "inputEvent", (s2) => {
      const t2 = s2.target, e2 = this.items.get(t2), n2 = t2.value, i2 = t2.selectionStart, h2 = t2.selectionEnd;
      let l = n2;
      if (e2.eager) {
        const r = e2.unmasked(n2), f = e2.masked(r);
        r === "" && "data" in s2 && s2.data != null ? l = s2.data : (f.startsWith(n2) || e2.completed(r)) && (l = r);
      }
      this.setMaskedValue(t2, l), "inputType" in s2 && (s2.inputType.startsWith("delete") || i2 != null && i2 < n2.length) && t2.setSelectionRange(i2, h2);
    });
    this.options = t;
    const { onMaska: e, preProcess: n, postProcess: i, ...h } = t;
    typeof s == "string" ? this.init(Array.from(document.querySelectorAll(s)), h) : this.init("length" in s ? Array.from(s) : [s], h);
  }
  destroy() {
    for (const s of this.items.keys())
      s.removeEventListener("input", this.inputEvent), s.removeEventListener("beforeinput", this.beforeinputEvent);
    this.items.clear();
  }
  init(s, t) {
    for (const e of s) {
      const n = { ...t };
      e.dataset.maska != null && e.dataset.maska !== "" && (n.mask = O(e.dataset.maska)), e.dataset.maskaEager != null && (n.eager = y(e.dataset.maskaEager)), e.dataset.maskaReversed != null && (n.reversed = y(e.dataset.maskaReversed)), e.dataset.maskaTokensReplace != null && (n.tokensReplace = y(e.dataset.maskaTokensReplace)), e.dataset.maskaTokens != null && (n.tokens = S(e.dataset.maskaTokens));
      const i = new L(n);
      this.items.set(e, i), e.value !== "" && this.setMaskedValue(e, e.value), e.addEventListener("input", this.inputEvent), e.addEventListener("beforeinput", this.beforeinputEvent);
    }
  }
  setMaskedValue(s, t) {
    const e = this.items.get(s);
    this.options.preProcess != null && (t = this.options.preProcess(t)), t = e.masked(t), this.options.postProcess != null && (t = this.options.postProcess(t)), s.value = t;
    const n = {
      masked: e.masked(t),
      unmasked: e.unmasked(t),
      completed: e.completed(t)
    };
    this.options.onMaska != null && (Array.isArray(this.options.onMaska) ? this.options.onMaska.forEach((i) => i(n)) : this.options.onMaska(n)), s.dispatchEvent(new CustomEvent("maska", { detail: n }));
  }
};
var E = /* @__PURE__ */ new WeakMap();
var x = (a, s) => {
  var n;
  const t = a instanceof HTMLInputElement ? a : a.querySelector("input");
  if (t == null)
    return;
  E.get(t) != null && ((n = E.get(t)) == null || n.destroy());
  const e = { ...s.arg };
  if (s.value != null) {
    const i = s.value, h = (l) => {
      i.masked = l.masked, i.unmasked = l.unmasked, i.completed = l.completed;
    };
    e.onMaska = e.onMaska == null ? h : Array.isArray(e.onMaska) ? [...e.onMaska, h] : [e.onMaska, h];
  }
  E.set(t, new j(t, e));
};
export {
  L as Mask,
  j as MaskInput,
  T as tokens,
  x as vMaska
};
/*! maska v2.0.1 | (c) Alexander Shabunevich | Released under the MIT license */
//# sourceMappingURL=maska.js.map
